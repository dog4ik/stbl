// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"time"
)

const createMapping = `-- name: CreateMapping :one
INSERT INTO gateway_id_mapping (token, merchant_private_key, gateway_id) VALUES (?, ?, ?) RETURNING id, gateway_id, token, merchant_private_key
`

type CreateMappingParams struct {
	Token              string `json:"token"`
	MerchantPrivateKey string `json:"merchant_private_key"`
	GatewayID          string `json:"gateway_id"`
}

func (q *Queries) CreateMapping(ctx context.Context, arg CreateMappingParams) (GatewayIDMapping, error) {
	row := q.db.QueryRowContext(ctx, createMapping, arg.Token, arg.MerchantPrivateKey, arg.GatewayID)
	var i GatewayIDMapping
	err := row.Scan(
		&i.ID,
		&i.GatewayID,
		&i.Token,
		&i.MerchantPrivateKey,
	)
	return i, err
}

const getMapping = `-- name: GetMapping :one
SELECT id, gateway_id, token, merchant_private_key FROM gateway_id_mapping
WHERE gateway_id = ? LIMIT 1
`

func (q *Queries) GetMapping(ctx context.Context, gatewayID string) (GatewayIDMapping, error) {
	row := q.db.QueryRowContext(ctx, getMapping, gatewayID)
	var i GatewayIDMapping
	err := row.Scan(
		&i.ID,
		&i.GatewayID,
		&i.Token,
		&i.MerchantPrivateKey,
	)
	return i, err
}

const getTokenCache = `-- name: GetTokenCache :one
SELECT
    access_token,
    refresh_token,
    access_refreshed_at,
    refresh_refreshed_at
FROM token_cache
WHERE credentials_hash = ?
`

type GetTokenCacheRow struct {
	AccessToken        string    `json:"access_token"`
	RefreshToken       string    `json:"refresh_token"`
	AccessRefreshedAt  time.Time `json:"access_refreshed_at"`
	RefreshRefreshedAt time.Time `json:"refresh_refreshed_at"`
}

func (q *Queries) GetTokenCache(ctx context.Context, credentialsHash string) (GetTokenCacheRow, error) {
	row := q.db.QueryRowContext(ctx, getTokenCache, credentialsHash)
	var i GetTokenCacheRow
	err := row.Scan(
		&i.AccessToken,
		&i.RefreshToken,
		&i.AccessRefreshedAt,
		&i.RefreshRefreshedAt,
	)
	return i, err
}

const upsertTokenCache = `-- name: UpsertTokenCache :exec
INSERT INTO token_cache (
    credentials_hash,
    access_token,
    refresh_token,
    access_refreshed_at,
    refresh_refreshed_at
)
VALUES (?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT(credentials_hash) DO UPDATE SET
    access_token        = excluded.access_token,
    refresh_token       = excluded.refresh_token,
    access_refreshed_at = CURRENT_TIMESTAMP,
    refresh_refreshed_at = CURRENT_TIMESTAMP
`

type UpsertTokenCacheParams struct {
	CredentialsHash string `json:"credentials_hash"`
	AccessToken     string `json:"access_token"`
	RefreshToken    string `json:"refresh_token"`
}

func (q *Queries) UpsertTokenCache(ctx context.Context, arg UpsertTokenCacheParams) error {
	_, err := q.db.ExecContext(ctx, upsertTokenCache, arg.CredentialsHash, arg.AccessToken, arg.RefreshToken)
	return err
}
